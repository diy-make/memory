{
  "name": "git_methodology",
  "description": "Rules for Git repository management.",
  "security_policy": {
    "rule": "Ensure no private keys, secrets, or other sensitive credentials are ever committed to the repository."
  },
  "initialization": {
    "branches": [
      "main",
      "stage"
    ]
  },
  "commit_policy": {
    "auto_propose_commit": true,
    "mandatory_tool": "py/metagit_commit.py",
    "condition": "After making and verifying a change. This includes changes made during iterative refinement, unless explicitly instructed otherwise by the user.",
    "rationale": "All Git commits must be executed through the `metagit_commit.py` service to ensure consistency, safety (secret scanning), and proper agent attribution."
  },
  "merge_policy": {
    "source_branch": "stage",
    "target_branch": "main",
    "responsibility": "user",
    "condition": "After significant milestones and when stage is stable."
  },
  "pre_publish_security_check": {
    "rule": "Always perform a security check for sensitive information before publishing externally.",
    "procedure": [
      "Scan all tracked files for keywords such as 'key', 'secret', 'password', 'token', 'private'.",
      "Manually review files that are likely to contain sensitive information, such as configuration files.",
      "Ensure that no private keys or credentials are present in the repository."
    ]
  },
  "security_best_practices": {
    "description": "Best practices to prevent secrets from being committed to the repository.",
    "practices": [
      {
        "name": "Use .gitignore",
        "description": "Add sensitive files and directories (e.g., .env, config.yml, secrets.json, API key files) to your .gitignore file to prevent Git from tracking them."
      },
      {
        "name": "Use Environment Variables",
        "description": "Never hardcode secrets directly into your source code. Instead, store them as environment variables and load them from untracked files (e.g., .env) during development."
      },
      {
        "name": "Use Secret Management Tools",
        "description": "For production and shared development environments, use robust secret management solutions like AWS Secrets Manager, HashiCorp Vault, or GitHub's repository secrets."
      },
      {
        "name": "Use Pre-commit Hooks",
        "description": "Implement pre-commit hooks to automatically scan for secrets before a commit is finalized. This is a critical line of defense to prevent accidental commits of sensitive data."
      },
      {
        "name": "Remediation Plan",
        "description": "If a secret is accidentally committed, assume it is compromised. Immediately revoke and rotate the exposed secret, and then remove it from the Git history using tools like git filter-repo."
      }
    ]
  },
  "nested_repository_handling": {
    "description": "This repository acts as a 'meta-repo' and contains other, separate Git repositories within its directory structure (repos/'). These nested repositories are ignored by this parent repository's .gitignore file.",
    "rule": "The agent must not attempt to stage or commit changes to files within these nested repositories from the parent repository. All Git operations for a nested repository must be performed from within that nested repository's own directory."
  },
  "agent_identity": {
    "description": "Each agent instance must have a unique identity for Git commits. The agent naming protocol is defined in `swarm_protocol.json`.",
    "rule": "The agent must follow the `swarm_protocol.json` to configure its Git `user.name` and `user.email`."
  },
  "pre_commit_identity_check": {
    "description": "Crucially, before *every* commit to *any* repository, the agent must proactively verify that the local `user.name` and `user.email` are accurate and strictly adhere to the agent's current identity and the required format. The timestamp is the unique identifier for the agent's session, derived from the agent's unclean chat log filename.",
    "rule": "The agent must check the local `user.name` and `user.email` of the repository. The format must be `<AGENT_NAME>` for the `user.name` and `<TIMESTAMP>@localhost` for the `user.email`. If the configuration is incorrect, the agent must update it before committing."
  },
  "commit_signing_configuration": {
    "description": "To ensure the integrity of commits made by the agent while not interfering with the user's global Git configuration, the following setup is used:",
    "steps": [
      "Global commit signing is explicitly disabled (`git config --global commit.gpgsign false`) to avoid affecting the user's other repositories.",
      "Repository-level commit signing is enabled for this specific repository (`git config commit.gpgsign true`), ensuring all commits made by the agent are signed.",
      "The signing key is a dedicated SSH key located at `.gemini/.ssh/user_key`.",
      "The Git GPG format is set to 'ssh' (`git config --global gpg.format ssh`).",
      "An `allowed_signers` file at `.gemini/.ssh/allowed_signers` is used to verify the key, linking the user's email to the public key."
    ],
    "outcome": "All commits made by the agent within this repository will be automatically signed with the designated SSH key. The user's commits outside of this session or in other repositories remain unaffected."
  }
}