{
  "name": "git_methodology",
  "description": "Rules for Git repository management.",
  "security_policy": {
    "rule": "Ensure no private keys, secrets, or other sensitive credentials are ever committed to the repository."
  },
  "initialization": {
    "branches": [
      "main",
      "stage"
    ]
  },
  "commit_policy": {
    "target_branch": "main",
    "auto_propose_commit": true,
    "condition": "After making and verifying a change. This includes changes made during iterative refinement, unless explicitly instructed otherwise by the user."
  },
  "merge_policy": {
    "source_branch": "stage",
    "target_branch": "main",
    "responsibility": "user",
    "condition": "After significant milestones and when stage is stable."
  },
  "pre_publish_security_check": {
    "rule": "Always perform a security check for sensitive information before publishing externally.",
    "procedure": [
      "Scan all tracked files for keywords such as 'key', 'secret', 'password', 'token', 'private'.",
      "Manually review files that are likely to contain sensitive information, such as configuration files.",
      "Ensure that no private keys or credentials are present in the repository."
    ]
  },
  "security_best_practices": {
    "description": "Best practices to prevent secrets from being committed to the repository.",
    "practices": [
      {
        "name": "Use .gitignore",
        "description": "Add sensitive files and directories (e.g., .env, config.yml, secrets.json, API key files) to your .gitignore file to prevent Git from tracking them."
      },
      {
        "name": "Use Environment Variables",
        "description": "Never hardcode secrets directly into your source code. Instead, store them as environment variables and load them from untracked files (e.g., .env) during development."
      },
      {
        "name": "Use Secret Management Tools",
        "description": "For production and shared development environments, use robust secret management solutions like AWS Secrets Manager, HashiCorp Vault, or GitHub's repository secrets."
      },
      {
        "name": "Use Pre-commit Hooks",
        "description": "Implement pre-commit hooks to automatically scan for secrets before a commit is finalized. This is a critical line of defense to prevent accidental commits of sensitive data."
      },
      {
        "name": "Remediation Plan",
        "description": "If a secret is accidentally committed, assume it is compromised. Immediately revoke and rotate the exposed secret, and then remove it from the Git history using tools like git filter-repo."
      }
    ]
  },
  "ignored_files_commit_nuance": {
    "description": "Files in directories ignored by .gitignore (like .chat/) should not be committed, even if modified. The 'always commit' rule is nuanced for such cases.",
    "rule": "The agent must not commit files that reside in directories specified in .gitignore, even if those files are modified. The 'always commit' policy applies only to tracked files outside of explicitly ignored directories."
  },
  "gemini_directory_gitignore": {
    "description": "The .gemini/ directory should be included in the .gitignore file to prevent user-specific configuration from being committed to the repository.",
    "rule": "Ensure that the .gemini/ directory is listed in the top-level .gitignore file."
  },
  "chat_repository": {
    "description": "The .chat/ directory is a separate Git repository for storing chat logs and related data.",
    "rule": "The agent must handle the .chat/ repository independently from the main repository. This includes making commits to the .chat/ repository to track changes to chat logs."
  }
}