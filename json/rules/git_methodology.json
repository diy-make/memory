{
  "name": "git_methodology",
  "description": "Rules for Git repository management.",
  "security_policy": {
    "rule": "Ensure no private keys, secrets, or other sensitive credentials are ever committed to the repository."
  },
  "sub_repository_git_operations": {
    "rule": "When performing git operations on a sub-repository (i.e., a Git repository nested within another Git repository), always change the current working directory to the sub-repository's root before executing the git command. After the operation, return to the original working directory. This avoids ambiguity in path resolution and prevents unintended interactions with the parent repository's Git context.",
    "rationale": "To prevent issues like files not being correctly staged or committed, or unintended deletions, which can occur when specifying relative paths from the parent repository's working directory while targeting a sub-repository's Git database."
  },
  "safe_directory_removal": {
    "rule": "Always use 'rmdir' instead of 'rm -rf' to remove directories. 'rmdir' will only succeed if the directory is empty, which provides a safety check against accidentally deleting important files.",
    "rationale": "To prevent accidental data loss and ensure that directories are empty before they are removed."
  },
  "initialization": {
    "branches": [
      "main",
      "stage"
    ]
  },
  "commit_policy": {
    "target_branch": "main",
    "auto_propose_commit": true,
    "auto_commit": true,
    "condition": "After making and verifying a change. This includes changes made during iterative refinement, unless explicitly instructed otherwise by the user."
  },
  "merge_policy": {
    "source_branch": "stage",
    "target_branch": "main",
    "responsibility": "user",
    "condition": "After significant milestones and when stage is stable."
  },
  "pre_publish_security_check": {
    "rule": "Always perform a security check for sensitive information before publishing externally.",
    "procedure": [
      "Scan all tracked files for keywords such as 'key', 'secret', 'password', 'token', 'private'.",
      "Manually review files that are likely to contain sensitive information, such as configuration files.",
      "Ensure that no private keys or credentials are present in the repository."
    ]
  },
  "security_best_practices": {
    "description": "Best practices to prevent secrets from being committed to the repository.",
    "practices": [
      {
        "name": "Effective Use of .gitignore",
        "description": "The first line of defense is to prevent sensitive files from being tracked by Git in the first place. I will ensure that files that commonly contain secrets (like `.env`, `config.yml`, `secrets.json`, etc.) are listed in the `.gitignore` file."
      },
      {
        "name": "Environment Variables",
        "description": "I will never hardcode secrets directly into the source code. Instead, I will use environment variables to store secrets. This allows you to keep your secrets separate from your code and load them from untracked files (like `.env`) during development."
      },
      {
        "name": "Secret Management Tools",
        "description": "For production and shared development environments, I will advocate for the use of robust secret management solutions like AWS Secrets Manager, HashiCorp Vault, or GitHub's repository secrets. These tools provide secure storage, access control, and other advanced features."
      },
      {
        "name": "Automated Scanning (Pre-commit Hooks)",
        "description": "I will use `pre-commit` hooks with `detect-secrets` to automatically scan for secrets before a commit is finalized. This is a critical line of defense."
      },
      {
        "name": "Continuous Monitoring",
        "description": "I will also advocate for integrating secret scanning into CI/CD pipelines. This catches secrets that might have bypassed local checks before they are deployed or widely distributed."
      },
      {
        "name": "Manual Review",
        "description": "I will manually review files that are likely to contain sensitive information, such as configuration files, scripts, and documentation, to ensure that no secrets have been inadvertently included."
      },
      {
        "name": "Remediation Plan",
        "description": "If a secret is accidentally committed, I will assume it is compromised. The first and most critical step is to immediately revoke and rotate the exposed secret. To completely remove the secret from the repository's history, I will use tools like `git filter-repo` to rewrite the Git history."
      }
    ]
  },
  "ignored_files_commit_nuance": {
    "description": "Files in directories ignored by .gitignore (like .chat/) should not be committed, even if modified. The 'always commit' rule is nuanced for such cases.",
    "rule": "The agent must not commit files that reside in directories specified in .gitignore, even if those files are modified. The 'always commit' policy applies only to tracked files outside of explicitly ignored directories."
  },
  "gemini_directory_gitignore": {
    "description": "The .gemini/ directory should be included in the .gitignore file to prevent user-specific configuration from being committed to the repository.",
    "rule": "Ensure that the .gemini/ directory is listed in the top-level .gitignore file."
  },
  "chat_repository": {
    "description": "The .chat/ directory is a separate Git repository for storing chat logs and related data.",
    "rule": "The agent must handle the .chat/ repository independently from the main repository. This includes making commits to the .chat/ repository to track changes to chat logs.",
    "unclean_log_modification": "The unclean chat logs in the .chat/unclean directory are expected to be modified during a session as the chat progresses. These modifications should be staged and committed as part of the session's activity."
  }
}
